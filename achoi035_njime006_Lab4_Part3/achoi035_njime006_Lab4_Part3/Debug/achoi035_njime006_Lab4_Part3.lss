
achoi035_njime006_Lab4_Part3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000d76  00000e0a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d76  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063e  00800110  00800110  00000e1a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e1a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000e4c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00000e8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000028f1  00000000  00000000  000010a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ef2  00000000  00000000  00003995  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000190c  00000000  00000000  00004887  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b4  00000000  00000000  00006194  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f81  00000000  00000000  00006748  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ef4  00000000  00000000  000076c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  000095bd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	65 c0       	rjmp	.+202    	; 0xcc <__ctors_end>
   2:	00 00       	nop
   4:	80 c0       	rjmp	.+256    	; 0x106 <__bad_interrupt>
   6:	00 00       	nop
   8:	7e c0       	rjmp	.+252    	; 0x106 <__bad_interrupt>
   a:	00 00       	nop
   c:	7c c0       	rjmp	.+248    	; 0x106 <__bad_interrupt>
   e:	00 00       	nop
  10:	7a c0       	rjmp	.+244    	; 0x106 <__bad_interrupt>
  12:	00 00       	nop
  14:	78 c0       	rjmp	.+240    	; 0x106 <__bad_interrupt>
  16:	00 00       	nop
  18:	76 c0       	rjmp	.+236    	; 0x106 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	74 c0       	rjmp	.+232    	; 0x106 <__bad_interrupt>
  1e:	00 00       	nop
  20:	72 c0       	rjmp	.+228    	; 0x106 <__bad_interrupt>
  22:	00 00       	nop
  24:	70 c0       	rjmp	.+224    	; 0x106 <__bad_interrupt>
  26:	00 00       	nop
  28:	6e c0       	rjmp	.+220    	; 0x106 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6c c0       	rjmp	.+216    	; 0x106 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6a c0       	rjmp	.+212    	; 0x106 <__bad_interrupt>
  32:	00 00       	nop
  34:	2e c3       	rjmp	.+1628   	; 0x692 <__vector_13>
  36:	00 00       	nop
  38:	66 c0       	rjmp	.+204    	; 0x106 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	64 c0       	rjmp	.+200    	; 0x106 <__bad_interrupt>
  3e:	00 00       	nop
  40:	62 c0       	rjmp	.+196    	; 0x106 <__bad_interrupt>
  42:	00 00       	nop
  44:	60 c0       	rjmp	.+192    	; 0x106 <__bad_interrupt>
  46:	00 00       	nop
  48:	5e c0       	rjmp	.+188    	; 0x106 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	5c c0       	rjmp	.+184    	; 0x106 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5a c0       	rjmp	.+180    	; 0x106 <__bad_interrupt>
  52:	00 00       	nop
  54:	58 c0       	rjmp	.+176    	; 0x106 <__bad_interrupt>
  56:	00 00       	nop
  58:	56 c0       	rjmp	.+172    	; 0x106 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	54 c0       	rjmp	.+168    	; 0x106 <__bad_interrupt>
  5e:	00 00       	nop
  60:	52 c0       	rjmp	.+164    	; 0x106 <__bad_interrupt>
  62:	00 00       	nop
  64:	50 c0       	rjmp	.+160    	; 0x106 <__bad_interrupt>
  66:	00 00       	nop
  68:	4e c0       	rjmp	.+156    	; 0x106 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4c c0       	rjmp	.+152    	; 0x106 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4a c0       	rjmp	.+148    	; 0x106 <__bad_interrupt>
  72:	00 00       	nop
  74:	48 c0       	rjmp	.+144    	; 0x106 <__bad_interrupt>
  76:	00 00       	nop
  78:	46 c0       	rjmp	.+140    	; 0x106 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	44 c0       	rjmp	.+136    	; 0x106 <__bad_interrupt>
  7e:	00 00       	nop
  80:	42 c0       	rjmp	.+132    	; 0x106 <__bad_interrupt>
  82:	00 00       	nop
  84:	40 c0       	rjmp	.+128    	; 0x106 <__bad_interrupt>
  86:	00 00       	nop
  88:	3e c0       	rjmp	.+124    	; 0x106 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	8f 00       	.word	0x008f	; ????
  8e:	91 00       	.word	0x0091	; ????
  90:	94 00       	.word	0x0094	; ????
  92:	97 00       	.word	0x0097	; ????
  94:	9a 00       	.word	0x009a	; ????
  96:	9d 00       	.word	0x009d	; ????
  98:	a0 00       	.word	0x00a0	; ????
  9a:	a3 00       	.word	0x00a3	; ????
  9c:	a6 00       	.word	0x00a6	; ????
  9e:	a9 00       	.word	0x00a9	; ????
  a0:	ac 00       	.word	0x00ac	; ????
  a2:	af 00       	.word	0x00af	; ????
  a4:	b2 00       	.word	0x00b2	; ????
  a6:	b5 00       	.word	0x00b5	; ????
  a8:	b8 00       	.word	0x00b8	; ????
  aa:	bb 00       	.word	0x00bb	; ????
  ac:	cb 00       	.word	0x00cb	; ????
  ae:	cf 00       	.word	0x00cf	; ????
  b0:	d3 00       	.word	0x00d3	; ????
  b2:	d7 00       	.word	0x00d7	; ????
  b4:	db 00       	.word	0x00db	; ????
  b6:	df 00       	.word	0x00df	; ????
  b8:	e3 00       	.word	0x00e3	; ????
  ba:	e7 00       	.word	0x00e7	; ????
  bc:	eb 00       	.word	0x00eb	; ????
  be:	ef 00       	.word	0x00ef	; ????
  c0:	f3 00       	.word	0x00f3	; ????
  c2:	f7 00       	.word	0x00f7	; ????
  c4:	fb 00       	.word	0x00fb	; ????
  c6:	ff 00       	.word	0x00ff	; ????
  c8:	03 01       	movw	r0, r6
  ca:	07 01       	movw	r0, r14

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf ef       	ldi	r28, 0xFF	; 255
  d2:	d0 e4       	ldi	r29, 0x40	; 64
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
  d8:	11 e0       	ldi	r17, 0x01	; 1
  da:	a0 e0       	ldi	r26, 0x00	; 0
  dc:	b1 e0       	ldi	r27, 0x01	; 1
  de:	e6 e7       	ldi	r30, 0x76	; 118
  e0:	fd e0       	ldi	r31, 0x0D	; 13
  e2:	00 e0       	ldi	r16, 0x00	; 0
  e4:	0b bf       	out	0x3b, r16	; 59
  e6:	02 c0       	rjmp	.+4      	; 0xec <__do_copy_data+0x14>
  e8:	07 90       	elpm	r0, Z+
  ea:	0d 92       	st	X+, r0
  ec:	a0 31       	cpi	r26, 0x10	; 16
  ee:	b1 07       	cpc	r27, r17
  f0:	d9 f7       	brne	.-10     	; 0xe8 <__do_copy_data+0x10>

000000f2 <__do_clear_bss>:
  f2:	27 e0       	ldi	r18, 0x07	; 7
  f4:	a0 e1       	ldi	r26, 0x10	; 16
  f6:	b1 e0       	ldi	r27, 0x01	; 1
  f8:	01 c0       	rjmp	.+2      	; 0xfc <.do_clear_bss_start>

000000fa <.do_clear_bss_loop>:
  fa:	1d 92       	st	X+, r1

000000fc <.do_clear_bss_start>:
  fc:	ae 34       	cpi	r26, 0x4E	; 78
  fe:	b2 07       	cpc	r27, r18
 100:	e1 f7       	brne	.-8      	; 0xfa <.do_clear_bss_loop>
 102:	a6 d0       	rcall	.+332    	; 0x250 <main>
 104:	36 c6       	rjmp	.+3180   	; 0xd72 <_exit>

00000106 <__bad_interrupt>:
 106:	7c cf       	rjmp	.-264    	; 0x0 <__vectors>

00000108 <LEDS_Tick>:
	led_state = INIT;
}

void LEDS_Tick(){
	//Actions
	switch(led_state){
 108:	e0 91 4d 07 	lds	r30, 0x074D	; 0x80074d <led_state>
 10c:	8e 2f       	mov	r24, r30
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	80 31       	cpi	r24, 0x10	; 16
 112:	91 05       	cpc	r25, r1
 114:	98 f5       	brcc	.+102    	; 0x17c <LEDS_Tick+0x74>
 116:	fc 01       	movw	r30, r24
 118:	ea 5b       	subi	r30, 0xBA	; 186
 11a:	ff 4f       	sbci	r31, 0xFF	; 255
 11c:	21 c6       	rjmp	.+3138   	; 0xd60 <__tablejump2__>
		case INIT:
		PORTD = 0;
 11e:	1b b8       	out	0x0b, r1	; 11
		break;
 120:	2e c0       	rjmp	.+92     	; 0x17e <LEDS_Tick+0x76>
		case L0:
		PORTD = 1;
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	8b b9       	out	0x0b, r24	; 11
		break;
 126:	2b c0       	rjmp	.+86     	; 0x17e <LEDS_Tick+0x76>
		case L1:
		PORTD = 2;
 128:	82 e0       	ldi	r24, 0x02	; 2
 12a:	8b b9       	out	0x0b, r24	; 11
		break;
 12c:	28 c0       	rjmp	.+80     	; 0x17e <LEDS_Tick+0x76>
		case L2:
		PORTD = 4;
 12e:	84 e0       	ldi	r24, 0x04	; 4
 130:	8b b9       	out	0x0b, r24	; 11
		break;
 132:	25 c0       	rjmp	.+74     	; 0x17e <LEDS_Tick+0x76>
		case L3:
		PORTD = 8;
 134:	88 e0       	ldi	r24, 0x08	; 8
 136:	8b b9       	out	0x0b, r24	; 11
		break;
 138:	22 c0       	rjmp	.+68     	; 0x17e <LEDS_Tick+0x76>
		case L4:
		PORTD = 16;
 13a:	80 e1       	ldi	r24, 0x10	; 16
 13c:	8b b9       	out	0x0b, r24	; 11
		break;
 13e:	1f c0       	rjmp	.+62     	; 0x17e <LEDS_Tick+0x76>
		case L5:
		PORTD = 32;
 140:	80 e2       	ldi	r24, 0x20	; 32
 142:	8b b9       	out	0x0b, r24	; 11
		break;
 144:	1c c0       	rjmp	.+56     	; 0x17e <LEDS_Tick+0x76>
		case L6:
		PORTD = 64;
 146:	80 e4       	ldi	r24, 0x40	; 64
 148:	8b b9       	out	0x0b, r24	; 11
		break;
 14a:	19 c0       	rjmp	.+50     	; 0x17e <LEDS_Tick+0x76>
		case L7:
		PORTD = 128;
 14c:	80 e8       	ldi	r24, 0x80	; 128
 14e:	8b b9       	out	0x0b, r24	; 11
		break;
 150:	16 c0       	rjmp	.+44     	; 0x17e <LEDS_Tick+0x76>
		case L22:
		PORTD = 64;
 152:	80 e4       	ldi	r24, 0x40	; 64
 154:	8b b9       	out	0x0b, r24	; 11
		break;
 156:	13 c0       	rjmp	.+38     	; 0x17e <LEDS_Tick+0x76>
		case L33:
		PORTD = 32;
 158:	80 e2       	ldi	r24, 0x20	; 32
 15a:	8b b9       	out	0x0b, r24	; 11
		break;
 15c:	10 c0       	rjmp	.+32     	; 0x17e <LEDS_Tick+0x76>
		case L44:
		PORTD = 16;
 15e:	80 e1       	ldi	r24, 0x10	; 16
 160:	8b b9       	out	0x0b, r24	; 11
		break;
 162:	0d c0       	rjmp	.+26     	; 0x17e <LEDS_Tick+0x76>
		case LOP:
		PORTD = 8;
 164:	88 e0       	ldi	r24, 0x08	; 8
 166:	8b b9       	out	0x0b, r24	; 11
		break;
 168:	0a c0       	rjmp	.+20     	; 0x17e <LEDS_Tick+0x76>
		case L55:
		PORTD = 4;
 16a:	84 e0       	ldi	r24, 0x04	; 4
 16c:	8b b9       	out	0x0b, r24	; 11
		break;
 16e:	07 c0       	rjmp	.+14     	; 0x17e <LEDS_Tick+0x76>
		case L66:
		PORTD = 2;
 170:	82 e0       	ldi	r24, 0x02	; 2
 172:	8b b9       	out	0x0b, r24	; 11
		break;
 174:	04 c0       	rjmp	.+8      	; 0x17e <LEDS_Tick+0x76>
		case L77:
		PORTD = 1;
 176:	81 e0       	ldi	r24, 0x01	; 1
 178:	8b b9       	out	0x0b, r24	; 11
		break;
 17a:	01 c0       	rjmp	.+2      	; 0x17e <LEDS_Tick+0x76>
		default:
		PORTD = 0;
 17c:	1b b8       	out	0x0b, r1	; 11
		break;
	}
	//Transitions
	switch(led_state){
 17e:	e0 91 4d 07 	lds	r30, 0x074D	; 0x80074d <led_state>
 182:	8e 2f       	mov	r24, r30
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	80 31       	cpi	r24, 0x10	; 16
 188:	91 05       	cpc	r25, r1
 18a:	08 f0       	brcs	.+2      	; 0x18e <LEDS_Tick+0x86>
 18c:	44 c0       	rjmp	.+136    	; 0x216 <LEDS_Tick+0x10e>
 18e:	fc 01       	movw	r30, r24
 190:	ea 5a       	subi	r30, 0xAA	; 170
 192:	ff 4f       	sbci	r31, 0xFF	; 255
 194:	e5 c5       	rjmp	.+3018   	; 0xd60 <__tablejump2__>
		case INIT:
			led_state = L0;
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 19c:	08 95       	ret
		case L0:
			led_state = L1;
 19e:	82 e0       	ldi	r24, 0x02	; 2
 1a0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1a4:	08 95       	ret
		case L1:
			led_state = L2;
 1a6:	83 e0       	ldi	r24, 0x03	; 3
 1a8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1ac:	08 95       	ret
		case L2:
			led_state = L3;
 1ae:	84 e0       	ldi	r24, 0x04	; 4
 1b0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1b4:	08 95       	ret
		case L3:
			led_state = L4;
 1b6:	85 e0       	ldi	r24, 0x05	; 5
 1b8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1bc:	08 95       	ret
		case L4:
			led_state = L5;
 1be:	86 e0       	ldi	r24, 0x06	; 6
 1c0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1c4:	08 95       	ret
		case L5:
			led_state = L6;
 1c6:	87 e0       	ldi	r24, 0x07	; 7
 1c8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1cc:	08 95       	ret
		case L6:
			led_state = L7;
 1ce:	88 e0       	ldi	r24, 0x08	; 8
 1d0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1d4:	08 95       	ret
		case L7:
			led_state = L22;
 1d6:	89 e0       	ldi	r24, 0x09	; 9
 1d8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1dc:	08 95       	ret
		
		case L22:
		led_state = L33;
 1de:	8a e0       	ldi	r24, 0x0A	; 10
 1e0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1e4:	08 95       	ret
		case L33:
		led_state = L44;
 1e6:	8b e0       	ldi	r24, 0x0B	; 11
 1e8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1ec:	08 95       	ret
		case L44:
		led_state = LOP;
 1ee:	8c e0       	ldi	r24, 0x0C	; 12
 1f0:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1f4:	08 95       	ret
		case LOP:
		led_state = L55;
 1f6:	8d e0       	ldi	r24, 0x0D	; 13
 1f8:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 1fc:	08 95       	ret
		case L55:
		led_state = L66;
 1fe:	8e e0       	ldi	r24, 0x0E	; 14
 200:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 204:	08 95       	ret
		case L66:
		led_state = L77;
 206:	8f e0       	ldi	r24, 0x0F	; 15
 208:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 20c:	08 95       	ret
		case L77:
		led_state = L0;
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	80 93 4d 07 	sts	0x074D, r24	; 0x80074d <led_state>
		break;
 214:	08 95       	ret
		default:
		led_state = INIT;
 216:	10 92 4d 07 	sts	0x074D, r1	; 0x80074d <led_state>
 21a:	08 95       	ret

0000021c <LedSecTask>:
#include "task.h" 
#include "croutine.h" 
enum LEDState {INIT,L0,L1,L2,L3,L4,L5,L6,L7,L22,L33,L44,LOP,L55,L66,L77} led_state;

void LEDS_Init(){
	led_state = INIT;
 21c:	10 92 4d 07 	sts	0x074D, r1	; 0x80074d <led_state>
}

void LedSecTask() {
    LEDS_Init();
    for(;;) { 	
        LEDS_Tick();
 220:	73 df       	rcall	.-282    	; 0x108 <LEDS_Tick>
        vTaskDelay(90); 
 222:	8a e5       	ldi	r24, 0x5A	; 90
 224:	90 e0       	ldi	r25, 0x00	; 0
 226:	26 d5       	rcall	.+2636   	; 0xc74 <vTaskDelay>
 228:	fb cf       	rjmp	.-10     	; 0x220 <LedSecTask+0x4>

0000022a <StartSecPulse>:
    } 
}

void StartSecPulse(unsigned portBASE_TYPE Priority) {
 22a:	ef 92       	push	r14
 22c:	ff 92       	push	r15
 22e:	0f 93       	push	r16
    xTaskCreate(LedSecTask, 
 230:	e1 2c       	mov	r14, r1
 232:	f1 2c       	mov	r15, r1
 234:	08 2f       	mov	r16, r24
 236:	20 e0       	ldi	r18, 0x00	; 0
 238:	30 e0       	ldi	r19, 0x00	; 0
 23a:	45 e5       	ldi	r20, 0x55	; 85
 23c:	50 e0       	ldi	r21, 0x00	; 0
 23e:	60 e0       	ldi	r22, 0x00	; 0
 240:	71 e0       	ldi	r23, 0x01	; 1
 242:	8e e0       	ldi	r24, 0x0E	; 14
 244:	91 e0       	ldi	r25, 0x01	; 1
 246:	bb d2       	rcall	.+1398   	; 0x7be <xTaskCreate>
            (signed portCHAR *)"LedSecTask", 
            configMINIMAL_STACK_SIZE, 
            NULL, 
            Priority, 
            NULL );
}	
 248:	0f 91       	pop	r16
 24a:	ff 90       	pop	r15
 24c:	ef 90       	pop	r14
 24e:	08 95       	ret

00000250 <main>:
 
int main(void) { 
    DDRA = 0x00; PORTA=0xFF;
 250:	11 b8       	out	0x01, r1	; 1
 252:	8f ef       	ldi	r24, 0xFF	; 255
 254:	82 b9       	out	0x02, r24	; 2
    DDRD = 0xFF;
 256:	8a b9       	out	0x0a, r24	; 10
    //Start Tasks  
    StartSecPulse(1);
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	e7 df       	rcall	.-50     	; 0x22a <StartSecPulse>
    //RunSchedular 
    vTaskStartScheduler(); 
 25c:	ad d3       	rcall	.+1882   	; 0x9b8 <vTaskStartScheduler>
 25e:	80 e0       	ldi	r24, 0x00	; 0
    return 0; 
}
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	08 95       	ret

00000264 <pvPortMalloc>:
 264:	cf 93       	push	r28
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 266:	df 93       	push	r29
 268:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 26a:	ce d3       	rcall	.+1948   	; 0xa08 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 26c:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
 270:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
 274:	89 2b       	or	r24, r25
 276:	31 f4       	brne	.+12     	; 0x284 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 278:	85 e1       	ldi	r24, 0x15	; 21
 27a:	91 e0       	ldi	r25, 0x01	; 1
 27c:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <__data_end+0x1>
 280:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 284:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <xNextFreeByte>
 288:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <xNextFreeByte+0x1>
 28c:	c9 01       	movw	r24, r18
 28e:	8c 0f       	add	r24, r28
 290:	9d 1f       	adc	r25, r29
 292:	8b 3d       	cpi	r24, 0xDB	; 219
 294:	45 e0       	ldi	r20, 0x05	; 5
 296:	94 07       	cpc	r25, r20
 298:	70 f4       	brcc	.+28     	; 0x2b6 <pvPortMalloc+0x52>
 29a:	28 17       	cp	r18, r24
 29c:	39 07       	cpc	r19, r25
 29e:	70 f4       	brcc	.+28     	; 0x2bc <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 2a0:	c0 91 10 01 	lds	r28, 0x0110	; 0x800110 <__data_end>
 2a4:	d0 91 11 01 	lds	r29, 0x0111	; 0x800111 <__data_end+0x1>
 2a8:	c2 0f       	add	r28, r18
 2aa:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 2ac:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xNextFreeByte+0x1>
 2b0:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xNextFreeByte>
 2b4:	05 c0       	rjmp	.+10     	; 0x2c0 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 2b6:	c0 e0       	ldi	r28, 0x00	; 0
 2b8:	d0 e0       	ldi	r29, 0x00	; 0
 2ba:	02 c0       	rjmp	.+4      	; 0x2c0 <pvPortMalloc+0x5c>
 2bc:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 2be:	d0 e0       	ldi	r29, 0x00	; 0
 2c0:	60 d4       	rcall	.+2240   	; 0xb82 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 2c2:	ce 01       	movw	r24, r28
 2c4:	df 91       	pop	r29
 2c6:	cf 91       	pop	r28
 2c8:	08 95       	ret

000002ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 2ca:	08 95       	ret

000002cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 2cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2ce:	03 96       	adiw	r24, 0x03	; 3
 2d0:	92 83       	std	Z+2, r25	; 0x02
 2d2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 2d4:	2f ef       	ldi	r18, 0xFF	; 255
 2d6:	3f ef       	ldi	r19, 0xFF	; 255
 2d8:	34 83       	std	Z+4, r19	; 0x04
 2da:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2dc:	96 83       	std	Z+6, r25	; 0x06
 2de:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2e0:	90 87       	std	Z+8, r25	; 0x08
 2e2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 2e4:	10 82       	st	Z, r1
 2e6:	08 95       	ret

000002e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 2e8:	fc 01       	movw	r30, r24
 2ea:	11 86       	std	Z+9, r1	; 0x09
 2ec:	10 86       	std	Z+8, r1	; 0x08
 2ee:	08 95       	ret

000002f0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 2f0:	cf 93       	push	r28
 2f2:	df 93       	push	r29
 2f4:	9c 01       	movw	r18, r24
 2f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 2f8:	dc 01       	movw	r26, r24
 2fa:	11 96       	adiw	r26, 0x01	; 1
 2fc:	cd 91       	ld	r28, X+
 2fe:	dc 91       	ld	r29, X
 300:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 302:	d3 83       	std	Z+3, r29	; 0x03
 304:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 306:	8c 81       	ldd	r24, Y+4	; 0x04
 308:	9d 81       	ldd	r25, Y+5	; 0x05
 30a:	95 83       	std	Z+5, r25	; 0x05
 30c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 30e:	8c 81       	ldd	r24, Y+4	; 0x04
 310:	9d 81       	ldd	r25, Y+5	; 0x05
 312:	dc 01       	movw	r26, r24
 314:	13 96       	adiw	r26, 0x03	; 3
 316:	7c 93       	st	X, r23
 318:	6e 93       	st	-X, r22
 31a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 31c:	7d 83       	std	Y+5, r23	; 0x05
 31e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 320:	31 87       	std	Z+9, r19	; 0x09
 322:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 324:	f9 01       	movw	r30, r18
 326:	80 81       	ld	r24, Z
 328:	8f 5f       	subi	r24, 0xFF	; 255
 32a:	80 83       	st	Z, r24
}
 32c:	df 91       	pop	r29
 32e:	cf 91       	pop	r28
 330:	08 95       	ret

00000332 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 332:	cf 93       	push	r28
 334:	df 93       	push	r29
 336:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 338:	48 81       	ld	r20, Y
 33a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 33c:	4f 3f       	cpi	r20, 0xFF	; 255
 33e:	2f ef       	ldi	r18, 0xFF	; 255
 340:	52 07       	cpc	r21, r18
 342:	21 f4       	brne	.+8      	; 0x34c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 344:	fc 01       	movw	r30, r24
 346:	a7 81       	ldd	r26, Z+7	; 0x07
 348:	b0 85       	ldd	r27, Z+8	; 0x08
 34a:	0d c0       	rjmp	.+26     	; 0x366 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 34c:	dc 01       	movw	r26, r24
 34e:	13 96       	adiw	r26, 0x03	; 3
 350:	01 c0       	rjmp	.+2      	; 0x354 <vListInsert+0x22>
 352:	df 01       	movw	r26, r30
 354:	12 96       	adiw	r26, 0x02	; 2
 356:	ed 91       	ld	r30, X+
 358:	fc 91       	ld	r31, X
 35a:	13 97       	sbiw	r26, 0x03	; 3
 35c:	20 81       	ld	r18, Z
 35e:	31 81       	ldd	r19, Z+1	; 0x01
 360:	42 17       	cp	r20, r18
 362:	53 07       	cpc	r21, r19
 364:	b0 f7       	brcc	.-20     	; 0x352 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 366:	12 96       	adiw	r26, 0x02	; 2
 368:	ed 91       	ld	r30, X+
 36a:	fc 91       	ld	r31, X
 36c:	13 97       	sbiw	r26, 0x03	; 3
 36e:	fb 83       	std	Y+3, r31	; 0x03
 370:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 372:	d5 83       	std	Z+5, r29	; 0x05
 374:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 376:	bd 83       	std	Y+5, r27	; 0x05
 378:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 37a:	13 96       	adiw	r26, 0x03	; 3
 37c:	dc 93       	st	X, r29
 37e:	ce 93       	st	-X, r28
 380:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 382:	99 87       	std	Y+9, r25	; 0x09
 384:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 386:	fc 01       	movw	r30, r24
 388:	20 81       	ld	r18, Z
 38a:	2f 5f       	subi	r18, 0xFF	; 255
 38c:	20 83       	st	Z, r18
}
 38e:	df 91       	pop	r29
 390:	cf 91       	pop	r28
 392:	08 95       	ret

00000394 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 394:	cf 93       	push	r28
 396:	df 93       	push	r29
 398:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 39a:	a0 85       	ldd	r26, Z+8	; 0x08
 39c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 39e:	c2 81       	ldd	r28, Z+2	; 0x02
 3a0:	d3 81       	ldd	r29, Z+3	; 0x03
 3a2:	84 81       	ldd	r24, Z+4	; 0x04
 3a4:	95 81       	ldd	r25, Z+5	; 0x05
 3a6:	9d 83       	std	Y+5, r25	; 0x05
 3a8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 3aa:	c4 81       	ldd	r28, Z+4	; 0x04
 3ac:	d5 81       	ldd	r29, Z+5	; 0x05
 3ae:	82 81       	ldd	r24, Z+2	; 0x02
 3b0:	93 81       	ldd	r25, Z+3	; 0x03
 3b2:	9b 83       	std	Y+3, r25	; 0x03
 3b4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 3b6:	11 96       	adiw	r26, 0x01	; 1
 3b8:	8d 91       	ld	r24, X+
 3ba:	9c 91       	ld	r25, X
 3bc:	12 97       	sbiw	r26, 0x02	; 2
 3be:	e8 17       	cp	r30, r24
 3c0:	f9 07       	cpc	r31, r25
 3c2:	31 f4       	brne	.+12     	; 0x3d0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 3c4:	84 81       	ldd	r24, Z+4	; 0x04
 3c6:	95 81       	ldd	r25, Z+5	; 0x05
 3c8:	12 96       	adiw	r26, 0x02	; 2
 3ca:	9c 93       	st	X, r25
 3cc:	8e 93       	st	-X, r24
 3ce:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 3d0:	11 86       	std	Z+9, r1	; 0x09
 3d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 3d4:	8c 91       	ld	r24, X
 3d6:	81 50       	subi	r24, 0x01	; 1
 3d8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 3da:	8c 91       	ld	r24, X
}
 3dc:	df 91       	pop	r29
 3de:	cf 91       	pop	r28
 3e0:	08 95       	ret

000003e2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 3e2:	31 e1       	ldi	r19, 0x11	; 17
 3e4:	fc 01       	movw	r30, r24
 3e6:	30 83       	st	Z, r19
 3e8:	31 97       	sbiw	r30, 0x01	; 1
 3ea:	22 e2       	ldi	r18, 0x22	; 34
 3ec:	20 83       	st	Z, r18
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	a3 e3       	ldi	r26, 0x33	; 51
 3f2:	a0 83       	st	Z, r26
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	60 83       	st	Z, r22
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	70 83       	st	Z, r23
 3fc:	31 97       	sbiw	r30, 0x01	; 1
 3fe:	10 82       	st	Z, r1
 400:	31 97       	sbiw	r30, 0x01	; 1
 402:	60 e8       	ldi	r22, 0x80	; 128
 404:	60 83       	st	Z, r22
 406:	31 97       	sbiw	r30, 0x01	; 1
 408:	10 82       	st	Z, r1
 40a:	31 97       	sbiw	r30, 0x01	; 1
 40c:	62 e0       	ldi	r22, 0x02	; 2
 40e:	60 83       	st	Z, r22
 410:	31 97       	sbiw	r30, 0x01	; 1
 412:	63 e0       	ldi	r22, 0x03	; 3
 414:	60 83       	st	Z, r22
 416:	31 97       	sbiw	r30, 0x01	; 1
 418:	64 e0       	ldi	r22, 0x04	; 4
 41a:	60 83       	st	Z, r22
 41c:	31 97       	sbiw	r30, 0x01	; 1
 41e:	65 e0       	ldi	r22, 0x05	; 5
 420:	60 83       	st	Z, r22
 422:	31 97       	sbiw	r30, 0x01	; 1
 424:	66 e0       	ldi	r22, 0x06	; 6
 426:	60 83       	st	Z, r22
 428:	31 97       	sbiw	r30, 0x01	; 1
 42a:	67 e0       	ldi	r22, 0x07	; 7
 42c:	60 83       	st	Z, r22
 42e:	31 97       	sbiw	r30, 0x01	; 1
 430:	68 e0       	ldi	r22, 0x08	; 8
 432:	60 83       	st	Z, r22
 434:	31 97       	sbiw	r30, 0x01	; 1
 436:	69 e0       	ldi	r22, 0x09	; 9
 438:	60 83       	st	Z, r22
 43a:	31 97       	sbiw	r30, 0x01	; 1
 43c:	60 e1       	ldi	r22, 0x10	; 16
 43e:	60 83       	st	Z, r22
 440:	31 97       	sbiw	r30, 0x01	; 1
 442:	30 83       	st	Z, r19
 444:	31 97       	sbiw	r30, 0x01	; 1
 446:	32 e1       	ldi	r19, 0x12	; 18
 448:	30 83       	st	Z, r19
 44a:	31 97       	sbiw	r30, 0x01	; 1
 44c:	33 e1       	ldi	r19, 0x13	; 19
 44e:	30 83       	st	Z, r19
 450:	31 97       	sbiw	r30, 0x01	; 1
 452:	34 e1       	ldi	r19, 0x14	; 20
 454:	30 83       	st	Z, r19
 456:	31 97       	sbiw	r30, 0x01	; 1
 458:	35 e1       	ldi	r19, 0x15	; 21
 45a:	30 83       	st	Z, r19
 45c:	31 97       	sbiw	r30, 0x01	; 1
 45e:	36 e1       	ldi	r19, 0x16	; 22
 460:	30 83       	st	Z, r19
 462:	31 97       	sbiw	r30, 0x01	; 1
 464:	37 e1       	ldi	r19, 0x17	; 23
 466:	30 83       	st	Z, r19
 468:	31 97       	sbiw	r30, 0x01	; 1
 46a:	38 e1       	ldi	r19, 0x18	; 24
 46c:	30 83       	st	Z, r19
 46e:	31 97       	sbiw	r30, 0x01	; 1
 470:	39 e1       	ldi	r19, 0x19	; 25
 472:	30 83       	st	Z, r19
 474:	31 97       	sbiw	r30, 0x01	; 1
 476:	30 e2       	ldi	r19, 0x20	; 32
 478:	30 83       	st	Z, r19
 47a:	31 97       	sbiw	r30, 0x01	; 1
 47c:	31 e2       	ldi	r19, 0x21	; 33
 47e:	30 83       	st	Z, r19
 480:	31 97       	sbiw	r30, 0x01	; 1
 482:	20 83       	st	Z, r18
 484:	31 97       	sbiw	r30, 0x01	; 1
 486:	23 e2       	ldi	r18, 0x23	; 35
 488:	20 83       	st	Z, r18
 48a:	31 97       	sbiw	r30, 0x01	; 1
 48c:	40 83       	st	Z, r20
 48e:	31 97       	sbiw	r30, 0x01	; 1
 490:	50 83       	st	Z, r21
 492:	31 97       	sbiw	r30, 0x01	; 1
 494:	26 e2       	ldi	r18, 0x26	; 38
 496:	20 83       	st	Z, r18
 498:	31 97       	sbiw	r30, 0x01	; 1
 49a:	27 e2       	ldi	r18, 0x27	; 39
 49c:	20 83       	st	Z, r18
 49e:	31 97       	sbiw	r30, 0x01	; 1
 4a0:	28 e2       	ldi	r18, 0x28	; 40
 4a2:	20 83       	st	Z, r18
 4a4:	31 97       	sbiw	r30, 0x01	; 1
 4a6:	29 e2       	ldi	r18, 0x29	; 41
 4a8:	20 83       	st	Z, r18
 4aa:	31 97       	sbiw	r30, 0x01	; 1
 4ac:	20 e3       	ldi	r18, 0x30	; 48
 4ae:	20 83       	st	Z, r18
 4b0:	31 97       	sbiw	r30, 0x01	; 1
 4b2:	21 e3       	ldi	r18, 0x31	; 49
 4b4:	20 83       	st	Z, r18
 4b6:	86 97       	sbiw	r24, 0x26	; 38
 4b8:	08 95       	ret

000004ba <xPortStartScheduler>:
 4ba:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 4be:	8c e7       	ldi	r24, 0x7C	; 124
 4c0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 4c4:	8b e0       	ldi	r24, 0x0B	; 11
 4c6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 4ca:	ef e6       	ldi	r30, 0x6F	; 111
 4cc:	f0 e0       	ldi	r31, 0x00	; 0
 4ce:	80 81       	ld	r24, Z
 4d0:	82 60       	ori	r24, 0x02	; 2
 4d2:	80 83       	st	Z, r24
 4d4:	a0 91 4b 07 	lds	r26, 0x074B	; 0x80074b <pxCurrentTCB>
 4d8:	b0 91 4c 07 	lds	r27, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 4dc:	cd 91       	ld	r28, X+
 4de:	cd bf       	out	0x3d, r28	; 61
 4e0:	dd 91       	ld	r29, X+
 4e2:	de bf       	out	0x3e, r29	; 62
 4e4:	ff 91       	pop	r31
 4e6:	ef 91       	pop	r30
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	bf 91       	pop	r27
 4ee:	af 91       	pop	r26
 4f0:	9f 91       	pop	r25
 4f2:	8f 91       	pop	r24
 4f4:	7f 91       	pop	r23
 4f6:	6f 91       	pop	r22
 4f8:	5f 91       	pop	r21
 4fa:	4f 91       	pop	r20
 4fc:	3f 91       	pop	r19
 4fe:	2f 91       	pop	r18
 500:	1f 91       	pop	r17
 502:	0f 91       	pop	r16
 504:	ff 90       	pop	r15
 506:	ef 90       	pop	r14
 508:	df 90       	pop	r13
 50a:	cf 90       	pop	r12
 50c:	bf 90       	pop	r11
 50e:	af 90       	pop	r10
 510:	9f 90       	pop	r9
 512:	8f 90       	pop	r8
 514:	7f 90       	pop	r7
 516:	6f 90       	pop	r6
 518:	5f 90       	pop	r5
 51a:	4f 90       	pop	r4
 51c:	3f 90       	pop	r3
 51e:	2f 90       	pop	r2
 520:	1f 90       	pop	r1
 522:	0f 90       	pop	r0
 524:	0f be       	out	0x3f, r0	; 63
 526:	0f 90       	pop	r0
 528:	08 95       	ret
 52a:	81 e0       	ldi	r24, 0x01	; 1
 52c:	08 95       	ret

0000052e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 52e:	0f 92       	push	r0
 530:	0f b6       	in	r0, 0x3f	; 63
 532:	f8 94       	cli
 534:	0f 92       	push	r0
 536:	1f 92       	push	r1
 538:	11 24       	eor	r1, r1
 53a:	2f 92       	push	r2
 53c:	3f 92       	push	r3
 53e:	4f 92       	push	r4
 540:	5f 92       	push	r5
 542:	6f 92       	push	r6
 544:	7f 92       	push	r7
 546:	8f 92       	push	r8
 548:	9f 92       	push	r9
 54a:	af 92       	push	r10
 54c:	bf 92       	push	r11
 54e:	cf 92       	push	r12
 550:	df 92       	push	r13
 552:	ef 92       	push	r14
 554:	ff 92       	push	r15
 556:	0f 93       	push	r16
 558:	1f 93       	push	r17
 55a:	2f 93       	push	r18
 55c:	3f 93       	push	r19
 55e:	4f 93       	push	r20
 560:	5f 93       	push	r21
 562:	6f 93       	push	r22
 564:	7f 93       	push	r23
 566:	8f 93       	push	r24
 568:	9f 93       	push	r25
 56a:	af 93       	push	r26
 56c:	bf 93       	push	r27
 56e:	cf 93       	push	r28
 570:	df 93       	push	r29
 572:	ef 93       	push	r30
 574:	ff 93       	push	r31
 576:	a0 91 4b 07 	lds	r26, 0x074B	; 0x80074b <pxCurrentTCB>
 57a:	b0 91 4c 07 	lds	r27, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 57e:	0d b6       	in	r0, 0x3d	; 61
 580:	0d 92       	st	X+, r0
 582:	0e b6       	in	r0, 0x3e	; 62
 584:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 586:	86 d3       	rcall	.+1804   	; 0xc94 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 588:	a0 91 4b 07 	lds	r26, 0x074B	; 0x80074b <pxCurrentTCB>
 58c:	b0 91 4c 07 	lds	r27, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 590:	cd 91       	ld	r28, X+
 592:	cd bf       	out	0x3d, r28	; 61
 594:	dd 91       	ld	r29, X+
 596:	de bf       	out	0x3e, r29	; 62
 598:	ff 91       	pop	r31
 59a:	ef 91       	pop	r30
 59c:	df 91       	pop	r29
 59e:	cf 91       	pop	r28
 5a0:	bf 91       	pop	r27
 5a2:	af 91       	pop	r26
 5a4:	9f 91       	pop	r25
 5a6:	8f 91       	pop	r24
 5a8:	7f 91       	pop	r23
 5aa:	6f 91       	pop	r22
 5ac:	5f 91       	pop	r21
 5ae:	4f 91       	pop	r20
 5b0:	3f 91       	pop	r19
 5b2:	2f 91       	pop	r18
 5b4:	1f 91       	pop	r17
 5b6:	0f 91       	pop	r16
 5b8:	ff 90       	pop	r15
 5ba:	ef 90       	pop	r14
 5bc:	df 90       	pop	r13
 5be:	cf 90       	pop	r12
 5c0:	bf 90       	pop	r11
 5c2:	af 90       	pop	r10
 5c4:	9f 90       	pop	r9
 5c6:	8f 90       	pop	r8
 5c8:	7f 90       	pop	r7
 5ca:	6f 90       	pop	r6
 5cc:	5f 90       	pop	r5
 5ce:	4f 90       	pop	r4
 5d0:	3f 90       	pop	r3
 5d2:	2f 90       	pop	r2
 5d4:	1f 90       	pop	r1
 5d6:	0f 90       	pop	r0
 5d8:	0f be       	out	0x3f, r0	; 63
 5da:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5dc:	08 95       	ret

000005de <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 5de:	0f 92       	push	r0
 5e0:	0f b6       	in	r0, 0x3f	; 63
 5e2:	f8 94       	cli
 5e4:	0f 92       	push	r0
 5e6:	1f 92       	push	r1
 5e8:	11 24       	eor	r1, r1
 5ea:	2f 92       	push	r2
 5ec:	3f 92       	push	r3
 5ee:	4f 92       	push	r4
 5f0:	5f 92       	push	r5
 5f2:	6f 92       	push	r6
 5f4:	7f 92       	push	r7
 5f6:	8f 92       	push	r8
 5f8:	9f 92       	push	r9
 5fa:	af 92       	push	r10
 5fc:	bf 92       	push	r11
 5fe:	cf 92       	push	r12
 600:	df 92       	push	r13
 602:	ef 92       	push	r14
 604:	ff 92       	push	r15
 606:	0f 93       	push	r16
 608:	1f 93       	push	r17
 60a:	2f 93       	push	r18
 60c:	3f 93       	push	r19
 60e:	4f 93       	push	r20
 610:	5f 93       	push	r21
 612:	6f 93       	push	r22
 614:	7f 93       	push	r23
 616:	8f 93       	push	r24
 618:	9f 93       	push	r25
 61a:	af 93       	push	r26
 61c:	bf 93       	push	r27
 61e:	cf 93       	push	r28
 620:	df 93       	push	r29
 622:	ef 93       	push	r30
 624:	ff 93       	push	r31
 626:	a0 91 4b 07 	lds	r26, 0x074B	; 0x80074b <pxCurrentTCB>
 62a:	b0 91 4c 07 	lds	r27, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 62e:	0d b6       	in	r0, 0x3d	; 61
 630:	0d 92       	st	X+, r0
 632:	0e b6       	in	r0, 0x3e	; 62
 634:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 636:	ee d1       	rcall	.+988    	; 0xa14 <xTaskIncrementTick>
 638:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 63a:	2c d3       	rcall	.+1624   	; 0xc94 <vTaskSwitchContext>
 63c:	a0 91 4b 07 	lds	r26, 0x074B	; 0x80074b <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
 640:	b0 91 4c 07 	lds	r27, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 644:	cd 91       	ld	r28, X+
 646:	cd bf       	out	0x3d, r28	; 61
 648:	dd 91       	ld	r29, X+
 64a:	de bf       	out	0x3e, r29	; 62
 64c:	ff 91       	pop	r31
 64e:	ef 91       	pop	r30
 650:	df 91       	pop	r29
 652:	cf 91       	pop	r28
 654:	bf 91       	pop	r27
 656:	af 91       	pop	r26
 658:	9f 91       	pop	r25
 65a:	8f 91       	pop	r24
 65c:	7f 91       	pop	r23
 65e:	6f 91       	pop	r22
 660:	5f 91       	pop	r21
 662:	4f 91       	pop	r20
 664:	3f 91       	pop	r19
 666:	2f 91       	pop	r18
 668:	1f 91       	pop	r17
 66a:	0f 91       	pop	r16
 66c:	ff 90       	pop	r15
 66e:	ef 90       	pop	r14
 670:	df 90       	pop	r13
 672:	cf 90       	pop	r12
 674:	bf 90       	pop	r11
 676:	af 90       	pop	r10
 678:	9f 90       	pop	r9
 67a:	8f 90       	pop	r8
 67c:	7f 90       	pop	r7
 67e:	6f 90       	pop	r6
 680:	5f 90       	pop	r5
 682:	4f 90       	pop	r4
 684:	3f 90       	pop	r3
 686:	2f 90       	pop	r2
 688:	1f 90       	pop	r1
 68a:	0f 90       	pop	r0
 68c:	0f be       	out	0x3f, r0	; 63
 68e:	0f 90       	pop	r0
 690:	08 95       	ret

00000692 <__vector_13>:

	asm volatile ( "ret" );
 692:	a5 df       	rcall	.-182    	; 0x5de <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 694:	18 95       	reti

00000696 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 696:	e0 91 13 07 	lds	r30, 0x0713	; 0x800713 <pxDelayedTaskList>
 69a:	f0 91 14 07 	lds	r31, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 69e:	80 81       	ld	r24, Z
 6a0:	81 11       	cpse	r24, r1
 6a2:	07 c0       	rjmp	.+14     	; 0x6b2 <prvResetNextTaskUnblockTime+0x1c>
 6a4:	8f ef       	ldi	r24, 0xFF	; 255
 6a6:	9f ef       	ldi	r25, 0xFF	; 255
 6a8:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 6ac:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xNextTaskUnblockTime>
 6b0:	08 95       	ret
 6b2:	e0 91 13 07 	lds	r30, 0x0713	; 0x800713 <pxDelayedTaskList>
 6b6:	f0 91 14 07 	lds	r31, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 6ba:	05 80       	ldd	r0, Z+5	; 0x05
 6bc:	f6 81       	ldd	r31, Z+6	; 0x06
 6be:	e0 2d       	mov	r30, r0
 6c0:	06 80       	ldd	r0, Z+6	; 0x06
 6c2:	f7 81       	ldd	r31, Z+7	; 0x07
 6c4:	e0 2d       	mov	r30, r0
 6c6:	82 81       	ldd	r24, Z+2	; 0x02
 6c8:	93 81       	ldd	r25, Z+3	; 0x03
 6ca:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 6ce:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xNextTaskUnblockTime>
 6d2:	08 95       	ret

000006d4 <prvIdleTask>:
 6d4:	0f ef       	ldi	r16, 0xFF	; 255
 6d6:	16 e0       	ldi	r17, 0x06	; 6
 6d8:	0f 2e       	mov	r0, r31
 6da:	f7 e2       	ldi	r31, 0x27	; 39
 6dc:	ef 2e       	mov	r14, r31
 6de:	f7 e0       	ldi	r31, 0x07	; 7
 6e0:	ff 2e       	mov	r15, r31
 6e2:	f0 2d       	mov	r31, r0
 6e4:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxDeletedTasksWaitingCleanUp>
 6e8:	88 23       	and	r24, r24
 6ea:	11 f1       	breq	.+68     	; 0x730 <prvIdleTask+0x5c>
 6ec:	0f b6       	in	r0, 0x3f	; 63
 6ee:	f8 94       	cli
 6f0:	0f 92       	push	r0
 6f2:	d8 01       	movw	r26, r16
 6f4:	15 96       	adiw	r26, 0x05	; 5
 6f6:	ed 91       	ld	r30, X+
 6f8:	fc 91       	ld	r31, X
 6fa:	16 97       	sbiw	r26, 0x06	; 6
 6fc:	c6 81       	ldd	r28, Z+6	; 0x06
 6fe:	d7 81       	ldd	r29, Z+7	; 0x07
 700:	ce 01       	movw	r24, r28
 702:	02 96       	adiw	r24, 0x02	; 2
 704:	47 de       	rcall	.-882    	; 0x394 <uxListRemove>
 706:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxCurrentNumberOfTasks>
 70a:	81 50       	subi	r24, 0x01	; 1
 70c:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxCurrentNumberOfTasks>
 710:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxDeletedTasksWaitingCleanUp>
 714:	81 50       	subi	r24, 0x01	; 1
 716:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxDeletedTasksWaitingCleanUp>
 71a:	0f 90       	pop	r0
 71c:	0f be       	out	0x3f, r0	; 63
 71e:	8f 89       	ldd	r24, Y+23	; 0x17
 720:	98 8d       	ldd	r25, Y+24	; 0x18
 722:	d3 dd       	rcall	.-1114   	; 0x2ca <vPortFree>
 724:	ce 01       	movw	r24, r28
 726:	d1 dd       	rcall	.-1118   	; 0x2ca <vPortFree>
 728:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxDeletedTasksWaitingCleanUp>
 72c:	81 11       	cpse	r24, r1
 72e:	de cf       	rjmp	.-68     	; 0x6ec <prvIdleTask+0x18>
 730:	f7 01       	movw	r30, r14
 732:	80 81       	ld	r24, Z
 734:	82 30       	cpi	r24, 0x02	; 2
 736:	b0 f2       	brcs	.-84     	; 0x6e4 <prvIdleTask+0x10>
 738:	fa de       	rcall	.-524    	; 0x52e <vPortYield>
 73a:	d4 cf       	rjmp	.-88     	; 0x6e4 <prvIdleTask+0x10>

0000073c <prvAddCurrentTaskToDelayedList>:
 73c:	0f 93       	push	r16
 73e:	1f 93       	push	r17
 740:	cf 93       	push	r28
 742:	df 93       	push	r29
 744:	ec 01       	movw	r28, r24
 746:	00 91 fb 06 	lds	r16, 0x06FB	; 0x8006fb <xTickCount>
 74a:	10 91 fc 06 	lds	r17, 0x06FC	; 0x8006fc <xTickCount+0x1>
 74e:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <pxCurrentTCB>
 752:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 756:	02 96       	adiw	r24, 0x02	; 2
 758:	1d de       	rcall	.-966    	; 0x394 <uxListRemove>
 75a:	c0 0f       	add	r28, r16
 75c:	d1 1f       	adc	r29, r17
 75e:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 762:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 766:	d3 83       	std	Z+3, r29	; 0x03
 768:	c2 83       	std	Z+2, r28	; 0x02
 76a:	c0 17       	cp	r28, r16
 76c:	d1 07       	cpc	r29, r17
 76e:	60 f4       	brcc	.+24     	; 0x788 <prvAddCurrentTaskToDelayedList+0x4c>
 770:	60 91 4b 07 	lds	r22, 0x074B	; 0x80074b <pxCurrentTCB>
 774:	70 91 4c 07 	lds	r23, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 778:	80 91 11 07 	lds	r24, 0x0711	; 0x800711 <pxOverflowDelayedTaskList>
 77c:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <pxOverflowDelayedTaskList+0x1>
 780:	6e 5f       	subi	r22, 0xFE	; 254
 782:	7f 4f       	sbci	r23, 0xFF	; 255
 784:	d6 dd       	rcall	.-1108   	; 0x332 <vListInsert>
 786:	16 c0       	rjmp	.+44     	; 0x7b4 <prvAddCurrentTaskToDelayedList+0x78>
 788:	60 91 4b 07 	lds	r22, 0x074B	; 0x80074b <pxCurrentTCB>
 78c:	70 91 4c 07 	lds	r23, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 790:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <pxDelayedTaskList>
 794:	90 91 14 07 	lds	r25, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 798:	6e 5f       	subi	r22, 0xFE	; 254
 79a:	7f 4f       	sbci	r23, 0xFF	; 255
 79c:	ca dd       	rcall	.-1132   	; 0x332 <vListInsert>
 79e:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <xNextTaskUnblockTime>
 7a2:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 7a6:	c8 17       	cp	r28, r24
 7a8:	d9 07       	cpc	r29, r25
 7aa:	20 f4       	brcc	.+8      	; 0x7b4 <prvAddCurrentTaskToDelayedList+0x78>
 7ac:	d0 93 f4 06 	sts	0x06F4, r29	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 7b0:	c0 93 f3 06 	sts	0x06F3, r28	; 0x8006f3 <xNextTaskUnblockTime>
 7b4:	df 91       	pop	r29
 7b6:	cf 91       	pop	r28
 7b8:	1f 91       	pop	r17
 7ba:	0f 91       	pop	r16
 7bc:	08 95       	ret

000007be <xTaskCreate>:
 7be:	4f 92       	push	r4
 7c0:	5f 92       	push	r5
 7c2:	6f 92       	push	r6
 7c4:	7f 92       	push	r7
 7c6:	8f 92       	push	r8
 7c8:	9f 92       	push	r9
 7ca:	af 92       	push	r10
 7cc:	bf 92       	push	r11
 7ce:	cf 92       	push	r12
 7d0:	df 92       	push	r13
 7d2:	ef 92       	push	r14
 7d4:	ff 92       	push	r15
 7d6:	0f 93       	push	r16
 7d8:	cf 93       	push	r28
 7da:	df 93       	push	r29
 7dc:	4c 01       	movw	r8, r24
 7de:	6b 01       	movw	r12, r22
 7e0:	5a 01       	movw	r10, r20
 7e2:	29 01       	movw	r4, r18
 7e4:	ca 01       	movw	r24, r20
 7e6:	3e dd       	rcall	.-1412   	; 0x264 <pvPortMalloc>
 7e8:	3c 01       	movw	r6, r24
 7ea:	89 2b       	or	r24, r25
 7ec:	09 f4       	brne	.+2      	; 0x7f0 <xTaskCreate+0x32>
 7ee:	d3 c0       	rjmp	.+422    	; 0x996 <xTaskCreate+0x1d8>
 7f0:	86 e2       	ldi	r24, 0x26	; 38
 7f2:	90 e0       	ldi	r25, 0x00	; 0
 7f4:	37 dd       	rcall	.-1426   	; 0x264 <pvPortMalloc>
 7f6:	ec 01       	movw	r28, r24
 7f8:	89 2b       	or	r24, r25
 7fa:	59 f0       	breq	.+22     	; 0x812 <xTaskCreate+0x54>
 7fc:	78 8e       	std	Y+24, r7	; 0x18
 7fe:	6f 8a       	std	Y+23, r6	; 0x17
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	a8 1a       	sub	r10, r24
 804:	b1 08       	sbc	r11, r1
 806:	a6 0c       	add	r10, r6
 808:	b7 1c       	adc	r11, r7
 80a:	c1 14       	cp	r12, r1
 80c:	d1 04       	cpc	r13, r1
 80e:	21 f4       	brne	.+8      	; 0x818 <xTaskCreate+0x5a>
 810:	1f c0       	rjmp	.+62     	; 0x850 <xTaskCreate+0x92>
 812:	c3 01       	movw	r24, r6
 814:	5a dd       	rcall	.-1356   	; 0x2ca <vPortFree>
 816:	bf c0       	rjmp	.+382    	; 0x996 <xTaskCreate+0x1d8>
 818:	d6 01       	movw	r26, r12
 81a:	8c 91       	ld	r24, X
 81c:	89 8f       	std	Y+25, r24	; 0x19
 81e:	8c 91       	ld	r24, X
 820:	88 23       	and	r24, r24
 822:	a1 f0       	breq	.+40     	; 0x84c <xTaskCreate+0x8e>
 824:	ae 01       	movw	r20, r28
 826:	46 5e       	subi	r20, 0xE6	; 230
 828:	5f 4f       	sbci	r21, 0xFF	; 255
 82a:	f6 01       	movw	r30, r12
 82c:	31 96       	adiw	r30, 0x01	; 1
 82e:	b8 e0       	ldi	r27, 0x08	; 8
 830:	cb 0e       	add	r12, r27
 832:	d1 1c       	adc	r13, r1
 834:	cf 01       	movw	r24, r30
 836:	21 91       	ld	r18, Z+
 838:	da 01       	movw	r26, r20
 83a:	2d 93       	st	X+, r18
 83c:	ad 01       	movw	r20, r26
 83e:	dc 01       	movw	r26, r24
 840:	8c 91       	ld	r24, X
 842:	88 23       	and	r24, r24
 844:	19 f0       	breq	.+6      	; 0x84c <xTaskCreate+0x8e>
 846:	ec 15       	cp	r30, r12
 848:	fd 05       	cpc	r31, r13
 84a:	a1 f7       	brne	.-24     	; 0x834 <xTaskCreate+0x76>
 84c:	18 a2       	std	Y+32, r1	; 0x20
 84e:	01 c0       	rjmp	.+2      	; 0x852 <xTaskCreate+0x94>
 850:	19 8e       	std	Y+25, r1	; 0x19
 852:	04 30       	cpi	r16, 0x04	; 4
 854:	08 f0       	brcs	.+2      	; 0x858 <xTaskCreate+0x9a>
 856:	03 e0       	ldi	r16, 0x03	; 3
 858:	0e 8b       	std	Y+22, r16	; 0x16
 85a:	6e 01       	movw	r12, r28
 85c:	b2 e0       	ldi	r27, 0x02	; 2
 85e:	cb 0e       	add	r12, r27
 860:	d1 1c       	adc	r13, r1
 862:	c6 01       	movw	r24, r12
 864:	41 dd       	rcall	.-1406   	; 0x2e8 <vListInitialiseItem>
 866:	ce 01       	movw	r24, r28
 868:	0c 96       	adiw	r24, 0x0c	; 12
 86a:	3e dd       	rcall	.-1412   	; 0x2e8 <vListInitialiseItem>
 86c:	d9 87       	std	Y+9, r29	; 0x09
 86e:	c8 87       	std	Y+8, r28	; 0x08
 870:	84 e0       	ldi	r24, 0x04	; 4
 872:	90 e0       	ldi	r25, 0x00	; 0
 874:	80 1b       	sub	r24, r16
 876:	91 09       	sbc	r25, r1
 878:	9d 87       	std	Y+13, r25	; 0x0d
 87a:	8c 87       	std	Y+12, r24	; 0x0c
 87c:	db 8b       	std	Y+19, r29	; 0x13
 87e:	ca 8b       	std	Y+18, r28	; 0x12
 880:	19 a2       	std	Y+33, r1	; 0x21
 882:	1a a2       	std	Y+34, r1	; 0x22
 884:	1b a2       	std	Y+35, r1	; 0x23
 886:	1c a2       	std	Y+36, r1	; 0x24
 888:	1d a2       	std	Y+37, r1	; 0x25
 88a:	a2 01       	movw	r20, r4
 88c:	b4 01       	movw	r22, r8
 88e:	c5 01       	movw	r24, r10
 890:	a8 dd       	rcall	.-1200   	; 0x3e2 <pxPortInitialiseStack>
 892:	99 83       	std	Y+1, r25	; 0x01
 894:	88 83       	st	Y, r24
 896:	e1 14       	cp	r14, r1
 898:	f1 04       	cpc	r15, r1
 89a:	19 f0       	breq	.+6      	; 0x8a2 <xTaskCreate+0xe4>
 89c:	f7 01       	movw	r30, r14
 89e:	d1 83       	std	Z+1, r29	; 0x01
 8a0:	c0 83       	st	Z, r28
 8a2:	0f b6       	in	r0, 0x3f	; 63
 8a4:	f8 94       	cli
 8a6:	0f 92       	push	r0
 8a8:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxCurrentNumberOfTasks>
 8ac:	8f 5f       	subi	r24, 0xFF	; 255
 8ae:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxCurrentNumberOfTasks>
 8b2:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <pxCurrentTCB>
 8b6:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 8ba:	89 2b       	or	r24, r25
 8bc:	69 f5       	brne	.+90     	; 0x918 <xTaskCreate+0x15a>
 8be:	d0 93 4c 07 	sts	0x074C, r29	; 0x80074c <pxCurrentTCB+0x1>
 8c2:	c0 93 4b 07 	sts	0x074B, r28	; 0x80074b <pxCurrentTCB>
 8c6:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxCurrentNumberOfTasks>
 8ca:	81 30       	cpi	r24, 0x01	; 1
 8cc:	a9 f5       	brne	.+106    	; 0x938 <xTaskCreate+0x17a>
 8ce:	87 e2       	ldi	r24, 0x27	; 39
 8d0:	97 e0       	ldi	r25, 0x07	; 7
 8d2:	fc dc       	rcall	.-1544   	; 0x2cc <vListInitialise>
 8d4:	80 e3       	ldi	r24, 0x30	; 48
 8d6:	97 e0       	ldi	r25, 0x07	; 7
 8d8:	f9 dc       	rcall	.-1550   	; 0x2cc <vListInitialise>
 8da:	89 e3       	ldi	r24, 0x39	; 57
 8dc:	97 e0       	ldi	r25, 0x07	; 7
 8de:	f6 dc       	rcall	.-1556   	; 0x2cc <vListInitialise>
 8e0:	82 e4       	ldi	r24, 0x42	; 66
 8e2:	97 e0       	ldi	r25, 0x07	; 7
 8e4:	f3 dc       	rcall	.-1562   	; 0x2cc <vListInitialise>
 8e6:	8e e1       	ldi	r24, 0x1E	; 30
 8e8:	97 e0       	ldi	r25, 0x07	; 7
 8ea:	f0 dc       	rcall	.-1568   	; 0x2cc <vListInitialise>
 8ec:	85 e1       	ldi	r24, 0x15	; 21
 8ee:	97 e0       	ldi	r25, 0x07	; 7
 8f0:	ed dc       	rcall	.-1574   	; 0x2cc <vListInitialise>
 8f2:	88 e0       	ldi	r24, 0x08	; 8
 8f4:	97 e0       	ldi	r25, 0x07	; 7
 8f6:	ea dc       	rcall	.-1580   	; 0x2cc <vListInitialise>
 8f8:	8f ef       	ldi	r24, 0xFF	; 255
 8fa:	96 e0       	ldi	r25, 0x06	; 6
 8fc:	e7 dc       	rcall	.-1586   	; 0x2cc <vListInitialise>
 8fe:	8e e1       	ldi	r24, 0x1E	; 30
 900:	97 e0       	ldi	r25, 0x07	; 7
 902:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <pxDelayedTaskList+0x1>
 906:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <pxDelayedTaskList>
 90a:	85 e1       	ldi	r24, 0x15	; 21
 90c:	97 e0       	ldi	r25, 0x07	; 7
 90e:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <pxOverflowDelayedTaskList+0x1>
 912:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <pxOverflowDelayedTaskList>
 916:	10 c0       	rjmp	.+32     	; 0x938 <xTaskCreate+0x17a>
 918:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <xSchedulerRunning>
 91c:	81 11       	cpse	r24, r1
 91e:	0c c0       	rjmp	.+24     	; 0x938 <xTaskCreate+0x17a>
 920:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 924:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 928:	96 89       	ldd	r25, Z+22	; 0x16
 92a:	8e 89       	ldd	r24, Y+22	; 0x16
 92c:	89 17       	cp	r24, r25
 92e:	20 f0       	brcs	.+8      	; 0x938 <xTaskCreate+0x17a>
 930:	d0 93 4c 07 	sts	0x074C, r29	; 0x80074c <pxCurrentTCB+0x1>
 934:	c0 93 4b 07 	sts	0x074B, r28	; 0x80074b <pxCurrentTCB>
 938:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <uxTaskNumber>
 93c:	8f 5f       	subi	r24, 0xFF	; 255
 93e:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <uxTaskNumber>
 942:	8e 89       	ldd	r24, Y+22	; 0x16
 944:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <uxTopReadyPriority>
 948:	98 17       	cp	r25, r24
 94a:	10 f4       	brcc	.+4      	; 0x950 <xTaskCreate+0x192>
 94c:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <uxTopReadyPriority>
 950:	90 e0       	ldi	r25, 0x00	; 0
 952:	9c 01       	movw	r18, r24
 954:	22 0f       	add	r18, r18
 956:	33 1f       	adc	r19, r19
 958:	22 0f       	add	r18, r18
 95a:	33 1f       	adc	r19, r19
 95c:	22 0f       	add	r18, r18
 95e:	33 1f       	adc	r19, r19
 960:	82 0f       	add	r24, r18
 962:	93 1f       	adc	r25, r19
 964:	b6 01       	movw	r22, r12
 966:	89 5d       	subi	r24, 0xD9	; 217
 968:	98 4f       	sbci	r25, 0xF8	; 248
 96a:	c2 dc       	rcall	.-1660   	; 0x2f0 <vListInsertEnd>
 96c:	0f 90       	pop	r0
 96e:	0f be       	out	0x3f, r0	; 63
 970:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <xSchedulerRunning>
 974:	88 23       	and	r24, r24
 976:	59 f0       	breq	.+22     	; 0x98e <xTaskCreate+0x1d0>
 978:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 97c:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 980:	96 89       	ldd	r25, Z+22	; 0x16
 982:	8e 89       	ldd	r24, Y+22	; 0x16
 984:	98 17       	cp	r25, r24
 986:	28 f4       	brcc	.+10     	; 0x992 <xTaskCreate+0x1d4>
 988:	d2 dd       	rcall	.-1116   	; 0x52e <vPortYield>
 98a:	81 e0       	ldi	r24, 0x01	; 1
 98c:	05 c0       	rjmp	.+10     	; 0x998 <xTaskCreate+0x1da>
 98e:	81 e0       	ldi	r24, 0x01	; 1
 990:	03 c0       	rjmp	.+6      	; 0x998 <xTaskCreate+0x1da>
 992:	81 e0       	ldi	r24, 0x01	; 1
 994:	01 c0       	rjmp	.+2      	; 0x998 <xTaskCreate+0x1da>
 996:	8f ef       	ldi	r24, 0xFF	; 255
 998:	df 91       	pop	r29
 99a:	cf 91       	pop	r28
 99c:	0f 91       	pop	r16
 99e:	ff 90       	pop	r15
 9a0:	ef 90       	pop	r14
 9a2:	df 90       	pop	r13
 9a4:	cf 90       	pop	r12
 9a6:	bf 90       	pop	r11
 9a8:	af 90       	pop	r10
 9aa:	9f 90       	pop	r9
 9ac:	8f 90       	pop	r8
 9ae:	7f 90       	pop	r7
 9b0:	6f 90       	pop	r6
 9b2:	5f 90       	pop	r5
 9b4:	4f 90       	pop	r4
 9b6:	08 95       	ret

000009b8 <vTaskStartScheduler>:
 9b8:	ef 92       	push	r14
 9ba:	ff 92       	push	r15
 9bc:	0f 93       	push	r16
 9be:	0f 2e       	mov	r0, r31
 9c0:	f1 ef       	ldi	r31, 0xF1	; 241
 9c2:	ef 2e       	mov	r14, r31
 9c4:	f6 e0       	ldi	r31, 0x06	; 6
 9c6:	ff 2e       	mov	r15, r31
 9c8:	f0 2d       	mov	r31, r0
 9ca:	00 e0       	ldi	r16, 0x00	; 0
 9cc:	20 e0       	ldi	r18, 0x00	; 0
 9ce:	30 e0       	ldi	r19, 0x00	; 0
 9d0:	45 e5       	ldi	r20, 0x55	; 85
 9d2:	50 e0       	ldi	r21, 0x00	; 0
 9d4:	6b e0       	ldi	r22, 0x0B	; 11
 9d6:	71 e0       	ldi	r23, 0x01	; 1
 9d8:	8a e6       	ldi	r24, 0x6A	; 106
 9da:	93 e0       	ldi	r25, 0x03	; 3
 9dc:	f0 de       	rcall	.-544    	; 0x7be <xTaskCreate>
 9de:	81 30       	cpi	r24, 0x01	; 1
 9e0:	79 f4       	brne	.+30     	; 0xa00 <vTaskStartScheduler+0x48>
 9e2:	f8 94       	cli
 9e4:	8f ef       	ldi	r24, 0xFF	; 255
 9e6:	9f ef       	ldi	r25, 0xFF	; 255
 9e8:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 9ec:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xNextTaskUnblockTime>
 9f0:	81 e0       	ldi	r24, 0x01	; 1
 9f2:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <xSchedulerRunning>
 9f6:	10 92 fc 06 	sts	0x06FC, r1	; 0x8006fc <xTickCount+0x1>
 9fa:	10 92 fb 06 	sts	0x06FB, r1	; 0x8006fb <xTickCount>
 9fe:	5d dd       	rcall	.-1350   	; 0x4ba <xPortStartScheduler>
 a00:	0f 91       	pop	r16
 a02:	ff 90       	pop	r15
 a04:	ef 90       	pop	r14
 a06:	08 95       	ret

00000a08 <vTaskSuspendAll>:
 a08:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <uxSchedulerSuspended>
 a0c:	8f 5f       	subi	r24, 0xFF	; 255
 a0e:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <uxSchedulerSuspended>
 a12:	08 95       	ret

00000a14 <xTaskIncrementTick>:
 a14:	cf 92       	push	r12
 a16:	df 92       	push	r13
 a18:	ef 92       	push	r14
 a1a:	ff 92       	push	r15
 a1c:	0f 93       	push	r16
 a1e:	1f 93       	push	r17
 a20:	cf 93       	push	r28
 a22:	df 93       	push	r29
 a24:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <uxSchedulerSuspended>
 a28:	81 11       	cpse	r24, r1
 a2a:	95 c0       	rjmp	.+298    	; 0xb56 <xTaskIncrementTick+0x142>
 a2c:	e0 90 fb 06 	lds	r14, 0x06FB	; 0x8006fb <xTickCount>
 a30:	f0 90 fc 06 	lds	r15, 0x06FC	; 0x8006fc <xTickCount+0x1>
 a34:	8f ef       	ldi	r24, 0xFF	; 255
 a36:	e8 1a       	sub	r14, r24
 a38:	f8 0a       	sbc	r15, r24
 a3a:	f0 92 fc 06 	sts	0x06FC, r15	; 0x8006fc <xTickCount+0x1>
 a3e:	e0 92 fb 06 	sts	0x06FB, r14	; 0x8006fb <xTickCount>
 a42:	e1 14       	cp	r14, r1
 a44:	f1 04       	cpc	r15, r1
 a46:	b1 f4       	brne	.+44     	; 0xa74 <xTaskIncrementTick+0x60>
 a48:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <pxDelayedTaskList>
 a4c:	90 91 14 07 	lds	r25, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 a50:	20 91 11 07 	lds	r18, 0x0711	; 0x800711 <pxOverflowDelayedTaskList>
 a54:	30 91 12 07 	lds	r19, 0x0712	; 0x800712 <pxOverflowDelayedTaskList+0x1>
 a58:	30 93 14 07 	sts	0x0714, r19	; 0x800714 <pxDelayedTaskList+0x1>
 a5c:	20 93 13 07 	sts	0x0713, r18	; 0x800713 <pxDelayedTaskList>
 a60:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <pxOverflowDelayedTaskList+0x1>
 a64:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <pxOverflowDelayedTaskList>
 a68:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <xNumOfOverflows>
 a6c:	8f 5f       	subi	r24, 0xFF	; 255
 a6e:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <xNumOfOverflows>
 a72:	11 de       	rcall	.-990    	; 0x696 <prvResetNextTaskUnblockTime>
 a74:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <xNextTaskUnblockTime>
 a78:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 a7c:	e8 16       	cp	r14, r24
 a7e:	f9 06       	cpc	r15, r25
 a80:	10 f4       	brcc	.+4      	; 0xa86 <xTaskIncrementTick+0x72>
 a82:	d1 2c       	mov	r13, r1
 a84:	50 c0       	rjmp	.+160    	; 0xb26 <xTaskIncrementTick+0x112>
 a86:	d1 2c       	mov	r13, r1
 a88:	cc 24       	eor	r12, r12
 a8a:	c3 94       	inc	r12
 a8c:	e0 91 13 07 	lds	r30, 0x0713	; 0x800713 <pxDelayedTaskList>
 a90:	f0 91 14 07 	lds	r31, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 a94:	80 81       	ld	r24, Z
 a96:	81 11       	cpse	r24, r1
 a98:	07 c0       	rjmp	.+14     	; 0xaa8 <xTaskIncrementTick+0x94>
 a9a:	8f ef       	ldi	r24, 0xFF	; 255
 a9c:	9f ef       	ldi	r25, 0xFF	; 255
 a9e:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 aa2:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xNextTaskUnblockTime>
 aa6:	3f c0       	rjmp	.+126    	; 0xb26 <xTaskIncrementTick+0x112>
 aa8:	e0 91 13 07 	lds	r30, 0x0713	; 0x800713 <pxDelayedTaskList>
 aac:	f0 91 14 07 	lds	r31, 0x0714	; 0x800714 <pxDelayedTaskList+0x1>
 ab0:	05 80       	ldd	r0, Z+5	; 0x05
 ab2:	f6 81       	ldd	r31, Z+6	; 0x06
 ab4:	e0 2d       	mov	r30, r0
 ab6:	c6 81       	ldd	r28, Z+6	; 0x06
 ab8:	d7 81       	ldd	r29, Z+7	; 0x07
 aba:	8a 81       	ldd	r24, Y+2	; 0x02
 abc:	9b 81       	ldd	r25, Y+3	; 0x03
 abe:	e8 16       	cp	r14, r24
 ac0:	f9 06       	cpc	r15, r25
 ac2:	28 f4       	brcc	.+10     	; 0xace <xTaskIncrementTick+0xba>
 ac4:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <xNextTaskUnblockTime+0x1>
 ac8:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <xNextTaskUnblockTime>
 acc:	2c c0       	rjmp	.+88     	; 0xb26 <xTaskIncrementTick+0x112>
 ace:	8e 01       	movw	r16, r28
 ad0:	0e 5f       	subi	r16, 0xFE	; 254
 ad2:	1f 4f       	sbci	r17, 0xFF	; 255
 ad4:	c8 01       	movw	r24, r16
 ad6:	5e dc       	rcall	.-1860   	; 0x394 <uxListRemove>
 ad8:	8c 89       	ldd	r24, Y+20	; 0x14
 ada:	9d 89       	ldd	r25, Y+21	; 0x15
 adc:	89 2b       	or	r24, r25
 ade:	19 f0       	breq	.+6      	; 0xae6 <xTaskIncrementTick+0xd2>
 ae0:	ce 01       	movw	r24, r28
 ae2:	0c 96       	adiw	r24, 0x0c	; 12
 ae4:	57 dc       	rcall	.-1874   	; 0x394 <uxListRemove>
 ae6:	8e 89       	ldd	r24, Y+22	; 0x16
 ae8:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <uxTopReadyPriority>
 aec:	98 17       	cp	r25, r24
 aee:	10 f4       	brcc	.+4      	; 0xaf4 <xTaskIncrementTick+0xe0>
 af0:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <uxTopReadyPriority>
 af4:	90 e0       	ldi	r25, 0x00	; 0
 af6:	9c 01       	movw	r18, r24
 af8:	22 0f       	add	r18, r18
 afa:	33 1f       	adc	r19, r19
 afc:	22 0f       	add	r18, r18
 afe:	33 1f       	adc	r19, r19
 b00:	22 0f       	add	r18, r18
 b02:	33 1f       	adc	r19, r19
 b04:	82 0f       	add	r24, r18
 b06:	93 1f       	adc	r25, r19
 b08:	b8 01       	movw	r22, r16
 b0a:	89 5d       	subi	r24, 0xD9	; 217
 b0c:	98 4f       	sbci	r25, 0xF8	; 248
 b0e:	f0 db       	rcall	.-2080   	; 0x2f0 <vListInsertEnd>
 b10:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 b14:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 b18:	9e 89       	ldd	r25, Y+22	; 0x16
 b1a:	86 89       	ldd	r24, Z+22	; 0x16
 b1c:	98 17       	cp	r25, r24
 b1e:	08 f4       	brcc	.+2      	; 0xb22 <xTaskIncrementTick+0x10e>
 b20:	b5 cf       	rjmp	.-150    	; 0xa8c <xTaskIncrementTick+0x78>
 b22:	dc 2c       	mov	r13, r12
 b24:	b3 cf       	rjmp	.-154    	; 0xa8c <xTaskIncrementTick+0x78>
 b26:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 b2a:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 b2e:	86 89       	ldd	r24, Z+22	; 0x16
 b30:	90 e0       	ldi	r25, 0x00	; 0
 b32:	fc 01       	movw	r30, r24
 b34:	ee 0f       	add	r30, r30
 b36:	ff 1f       	adc	r31, r31
 b38:	ee 0f       	add	r30, r30
 b3a:	ff 1f       	adc	r31, r31
 b3c:	ee 0f       	add	r30, r30
 b3e:	ff 1f       	adc	r31, r31
 b40:	8e 0f       	add	r24, r30
 b42:	9f 1f       	adc	r25, r31
 b44:	fc 01       	movw	r30, r24
 b46:	e9 5d       	subi	r30, 0xD9	; 217
 b48:	f8 4f       	sbci	r31, 0xF8	; 248
 b4a:	80 81       	ld	r24, Z
 b4c:	82 30       	cpi	r24, 0x02	; 2
 b4e:	48 f0       	brcs	.+18     	; 0xb62 <xTaskIncrementTick+0x14e>
 b50:	dd 24       	eor	r13, r13
 b52:	d3 94       	inc	r13
 b54:	06 c0       	rjmp	.+12     	; 0xb62 <xTaskIncrementTick+0x14e>
 b56:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxPendedTicks>
 b5a:	8f 5f       	subi	r24, 0xFF	; 255
 b5c:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <uxPendedTicks>
 b60:	d1 2c       	mov	r13, r1
 b62:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xYieldPending>
 b66:	88 23       	and	r24, r24
 b68:	11 f0       	breq	.+4      	; 0xb6e <xTaskIncrementTick+0x15a>
 b6a:	dd 24       	eor	r13, r13
 b6c:	d3 94       	inc	r13
 b6e:	8d 2d       	mov	r24, r13
 b70:	df 91       	pop	r29
 b72:	cf 91       	pop	r28
 b74:	1f 91       	pop	r17
 b76:	0f 91       	pop	r16
 b78:	ff 90       	pop	r15
 b7a:	ef 90       	pop	r14
 b7c:	df 90       	pop	r13
 b7e:	cf 90       	pop	r12
 b80:	08 95       	ret

00000b82 <xTaskResumeAll>:
 b82:	df 92       	push	r13
 b84:	ef 92       	push	r14
 b86:	ff 92       	push	r15
 b88:	0f 93       	push	r16
 b8a:	1f 93       	push	r17
 b8c:	cf 93       	push	r28
 b8e:	df 93       	push	r29
 b90:	0f b6       	in	r0, 0x3f	; 63
 b92:	f8 94       	cli
 b94:	0f 92       	push	r0
 b96:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <uxSchedulerSuspended>
 b9a:	81 50       	subi	r24, 0x01	; 1
 b9c:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <uxSchedulerSuspended>
 ba0:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <uxSchedulerSuspended>
 ba4:	81 11       	cpse	r24, r1
 ba6:	59 c0       	rjmp	.+178    	; 0xc5a <xTaskResumeAll+0xd8>
 ba8:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxCurrentNumberOfTasks>
 bac:	81 11       	cpse	r24, r1
 bae:	30 c0       	rjmp	.+96     	; 0xc10 <xTaskResumeAll+0x8e>
 bb0:	57 c0       	rjmp	.+174    	; 0xc60 <xTaskResumeAll+0xde>
 bb2:	d7 01       	movw	r26, r14
 bb4:	15 96       	adiw	r26, 0x05	; 5
 bb6:	ed 91       	ld	r30, X+
 bb8:	fc 91       	ld	r31, X
 bba:	16 97       	sbiw	r26, 0x06	; 6
 bbc:	c6 81       	ldd	r28, Z+6	; 0x06
 bbe:	d7 81       	ldd	r29, Z+7	; 0x07
 bc0:	ce 01       	movw	r24, r28
 bc2:	0c 96       	adiw	r24, 0x0c	; 12
 bc4:	e7 db       	rcall	.-2098   	; 0x394 <uxListRemove>
 bc6:	8e 01       	movw	r16, r28
 bc8:	0e 5f       	subi	r16, 0xFE	; 254
 bca:	1f 4f       	sbci	r17, 0xFF	; 255
 bcc:	c8 01       	movw	r24, r16
 bce:	e2 db       	rcall	.-2108   	; 0x394 <uxListRemove>
 bd0:	8e 89       	ldd	r24, Y+22	; 0x16
 bd2:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <uxTopReadyPriority>
 bd6:	98 17       	cp	r25, r24
 bd8:	10 f4       	brcc	.+4      	; 0xbde <xTaskResumeAll+0x5c>
 bda:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <uxTopReadyPriority>
 bde:	90 e0       	ldi	r25, 0x00	; 0
 be0:	9c 01       	movw	r18, r24
 be2:	22 0f       	add	r18, r18
 be4:	33 1f       	adc	r19, r19
 be6:	22 0f       	add	r18, r18
 be8:	33 1f       	adc	r19, r19
 bea:	22 0f       	add	r18, r18
 bec:	33 1f       	adc	r19, r19
 bee:	82 0f       	add	r24, r18
 bf0:	93 1f       	adc	r25, r19
 bf2:	b8 01       	movw	r22, r16
 bf4:	89 5d       	subi	r24, 0xD9	; 217
 bf6:	98 4f       	sbci	r25, 0xF8	; 248
 bf8:	7b db       	rcall	.-2314   	; 0x2f0 <vListInsertEnd>
 bfa:	e0 91 4b 07 	lds	r30, 0x074B	; 0x80074b <pxCurrentTCB>
 bfe:	f0 91 4c 07 	lds	r31, 0x074C	; 0x80074c <pxCurrentTCB+0x1>
 c02:	9e 89       	ldd	r25, Y+22	; 0x16
 c04:	86 89       	ldd	r24, Z+22	; 0x16
 c06:	98 17       	cp	r25, r24
 c08:	68 f0       	brcs	.+26     	; 0xc24 <xTaskResumeAll+0xa2>
 c0a:	d0 92 f7 06 	sts	0x06F7, r13	; 0x8006f7 <xYieldPending>
 c0e:	0a c0       	rjmp	.+20     	; 0xc24 <xTaskResumeAll+0xa2>
 c10:	c0 e0       	ldi	r28, 0x00	; 0
 c12:	d0 e0       	ldi	r29, 0x00	; 0
 c14:	0f 2e       	mov	r0, r31
 c16:	f8 e0       	ldi	r31, 0x08	; 8
 c18:	ef 2e       	mov	r14, r31
 c1a:	f7 e0       	ldi	r31, 0x07	; 7
 c1c:	ff 2e       	mov	r15, r31
 c1e:	f0 2d       	mov	r31, r0
 c20:	dd 24       	eor	r13, r13
 c22:	d3 94       	inc	r13
 c24:	f7 01       	movw	r30, r14
 c26:	80 81       	ld	r24, Z
 c28:	81 11       	cpse	r24, r1
 c2a:	c3 cf       	rjmp	.-122    	; 0xbb2 <xTaskResumeAll+0x30>
 c2c:	cd 2b       	or	r28, r29
 c2e:	09 f0       	breq	.+2      	; 0xc32 <xTaskResumeAll+0xb0>
 c30:	32 dd       	rcall	.-1436   	; 0x696 <prvResetNextTaskUnblockTime>
 c32:	c0 91 f8 06 	lds	r28, 0x06F8	; 0x8006f8 <uxPendedTicks>
 c36:	cc 23       	and	r28, r28
 c38:	49 f0       	breq	.+18     	; 0xc4c <xTaskResumeAll+0xca>
 c3a:	d1 e0       	ldi	r29, 0x01	; 1
 c3c:	eb de       	rcall	.-554    	; 0xa14 <xTaskIncrementTick>
 c3e:	81 11       	cpse	r24, r1
 c40:	d0 93 f7 06 	sts	0x06F7, r29	; 0x8006f7 <xYieldPending>
 c44:	c1 50       	subi	r28, 0x01	; 1
 c46:	d1 f7       	brne	.-12     	; 0xc3c <xTaskResumeAll+0xba>
 c48:	10 92 f8 06 	sts	0x06F8, r1	; 0x8006f8 <uxPendedTicks>
 c4c:	80 91 f7 06 	lds	r24, 0x06F7	; 0x8006f7 <xYieldPending>
 c50:	88 23       	and	r24, r24
 c52:	29 f0       	breq	.+10     	; 0xc5e <xTaskResumeAll+0xdc>
 c54:	6c dc       	rcall	.-1832   	; 0x52e <vPortYield>
 c56:	81 e0       	ldi	r24, 0x01	; 1
 c58:	03 c0       	rjmp	.+6      	; 0xc60 <xTaskResumeAll+0xde>
 c5a:	80 e0       	ldi	r24, 0x00	; 0
 c5c:	01 c0       	rjmp	.+2      	; 0xc60 <xTaskResumeAll+0xde>
 c5e:	80 e0       	ldi	r24, 0x00	; 0
 c60:	0f 90       	pop	r0
 c62:	0f be       	out	0x3f, r0	; 63
 c64:	df 91       	pop	r29
 c66:	cf 91       	pop	r28
 c68:	1f 91       	pop	r17
 c6a:	0f 91       	pop	r16
 c6c:	ff 90       	pop	r15
 c6e:	ef 90       	pop	r14
 c70:	df 90       	pop	r13
 c72:	08 95       	ret

00000c74 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 c74:	cf 93       	push	r28
 c76:	df 93       	push	r29
 c78:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 c7a:	89 2b       	or	r24, r25
 c7c:	39 f0       	breq	.+14     	; 0xc8c <vTaskDelay+0x18>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c7e:	c4 de       	rcall	.-632    	; 0xa08 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 c80:	60 e0       	ldi	r22, 0x00	; 0
 c82:	ce 01       	movw	r24, r28
			}
			xAlreadyYielded = xTaskResumeAll();
 c84:	5b dd       	rcall	.-1354   	; 0x73c <prvAddCurrentTaskToDelayedList>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c86:	7d df       	rcall	.-262    	; 0xb82 <xTaskResumeAll>
 c88:	81 11       	cpse	r24, r1
		{
			portYIELD_WITHIN_API();
 c8a:	01 c0       	rjmp	.+2      	; 0xc8e <vTaskDelay+0x1a>
 c8c:	50 dc       	rcall	.-1888   	; 0x52e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 c8e:	df 91       	pop	r29
 c90:	cf 91       	pop	r28
 c92:	08 95       	ret

00000c94 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c94:	80 91 f0 06 	lds	r24, 0x06F0	; 0x8006f0 <uxSchedulerSuspended>
 c98:	88 23       	and	r24, r24
 c9a:	21 f0       	breq	.+8      	; 0xca4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c9c:	81 e0       	ldi	r24, 0x01	; 1
 c9e:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <xYieldPending>
 ca2:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 ca4:	10 92 f7 06 	sts	0x06F7, r1	; 0x8006f7 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 ca8:	20 91 fa 06 	lds	r18, 0x06FA	; 0x8006fa <uxTopReadyPriority>
 cac:	82 2f       	mov	r24, r18
 cae:	90 e0       	ldi	r25, 0x00	; 0
 cb0:	fc 01       	movw	r30, r24
 cb2:	ee 0f       	add	r30, r30
 cb4:	ff 1f       	adc	r31, r31
 cb6:	ee 0f       	add	r30, r30
 cb8:	ff 1f       	adc	r31, r31
 cba:	ee 0f       	add	r30, r30
 cbc:	ff 1f       	adc	r31, r31
 cbe:	e8 0f       	add	r30, r24
 cc0:	f9 1f       	adc	r31, r25
 cc2:	e9 5d       	subi	r30, 0xD9	; 217
 cc4:	f8 4f       	sbci	r31, 0xF8	; 248
 cc6:	30 81       	ld	r19, Z
 cc8:	31 11       	cpse	r19, r1
 cca:	11 c0       	rjmp	.+34     	; 0xcee <vTaskSwitchContext+0x5a>
 ccc:	21 50       	subi	r18, 0x01	; 1
 cce:	82 2f       	mov	r24, r18
 cd0:	90 e0       	ldi	r25, 0x00	; 0
 cd2:	fc 01       	movw	r30, r24
 cd4:	ee 0f       	add	r30, r30
 cd6:	ff 1f       	adc	r31, r31
 cd8:	ee 0f       	add	r30, r30
 cda:	ff 1f       	adc	r31, r31
 cdc:	ee 0f       	add	r30, r30
 cde:	ff 1f       	adc	r31, r31
 ce0:	e8 0f       	add	r30, r24
 ce2:	f9 1f       	adc	r31, r25
 ce4:	e9 5d       	subi	r30, 0xD9	; 217
 ce6:	f8 4f       	sbci	r31, 0xF8	; 248
 ce8:	30 81       	ld	r19, Z
 cea:	33 23       	and	r19, r19
 cec:	79 f3       	breq	.-34     	; 0xccc <vTaskSwitchContext+0x38>
 cee:	ac 01       	movw	r20, r24
 cf0:	44 0f       	add	r20, r20
 cf2:	55 1f       	adc	r21, r21
 cf4:	44 0f       	add	r20, r20
 cf6:	55 1f       	adc	r21, r21
 cf8:	44 0f       	add	r20, r20
 cfa:	55 1f       	adc	r21, r21
 cfc:	48 0f       	add	r20, r24
 cfe:	59 1f       	adc	r21, r25
 d00:	da 01       	movw	r26, r20
 d02:	a9 5d       	subi	r26, 0xD9	; 217
 d04:	b8 4f       	sbci	r27, 0xF8	; 248
 d06:	11 96       	adiw	r26, 0x01	; 1
 d08:	ed 91       	ld	r30, X+
 d0a:	fc 91       	ld	r31, X
 d0c:	12 97       	sbiw	r26, 0x02	; 2
 d0e:	02 80       	ldd	r0, Z+2	; 0x02
 d10:	f3 81       	ldd	r31, Z+3	; 0x03
 d12:	e0 2d       	mov	r30, r0
 d14:	12 96       	adiw	r26, 0x02	; 2
 d16:	fc 93       	st	X, r31
 d18:	ee 93       	st	-X, r30
 d1a:	11 97       	sbiw	r26, 0x01	; 1
 d1c:	46 5d       	subi	r20, 0xD6	; 214
 d1e:	58 4f       	sbci	r21, 0xF8	; 248
 d20:	e4 17       	cp	r30, r20
 d22:	f5 07       	cpc	r31, r21
 d24:	29 f4       	brne	.+10     	; 0xd30 <vTaskSwitchContext+0x9c>
 d26:	42 81       	ldd	r20, Z+2	; 0x02
 d28:	53 81       	ldd	r21, Z+3	; 0x03
 d2a:	fd 01       	movw	r30, r26
 d2c:	52 83       	std	Z+2, r21	; 0x02
 d2e:	41 83       	std	Z+1, r20	; 0x01
 d30:	fc 01       	movw	r30, r24
 d32:	ee 0f       	add	r30, r30
 d34:	ff 1f       	adc	r31, r31
 d36:	ee 0f       	add	r30, r30
 d38:	ff 1f       	adc	r31, r31
 d3a:	ee 0f       	add	r30, r30
 d3c:	ff 1f       	adc	r31, r31
 d3e:	8e 0f       	add	r24, r30
 d40:	9f 1f       	adc	r25, r31
 d42:	fc 01       	movw	r30, r24
 d44:	e9 5d       	subi	r30, 0xD9	; 217
 d46:	f8 4f       	sbci	r31, 0xF8	; 248
 d48:	01 80       	ldd	r0, Z+1	; 0x01
 d4a:	f2 81       	ldd	r31, Z+2	; 0x02
 d4c:	e0 2d       	mov	r30, r0
 d4e:	86 81       	ldd	r24, Z+6	; 0x06
 d50:	97 81       	ldd	r25, Z+7	; 0x07
 d52:	90 93 4c 07 	sts	0x074C, r25	; 0x80074c <pxCurrentTCB+0x1>
 d56:	80 93 4b 07 	sts	0x074B, r24	; 0x80074b <pxCurrentTCB>
 d5a:	20 93 fa 06 	sts	0x06FA, r18	; 0x8006fa <uxTopReadyPriority>
 d5e:	08 95       	ret

00000d60 <__tablejump2__>:
 d60:	ee 0f       	add	r30, r30
 d62:	ff 1f       	adc	r31, r31
 d64:	00 24       	eor	r0, r0
 d66:	00 1c       	adc	r0, r0
 d68:	0b be       	out	0x3b, r0	; 59
 d6a:	07 90       	elpm	r0, Z+
 d6c:	f6 91       	elpm	r31, Z
 d6e:	e0 2d       	mov	r30, r0
 d70:	09 94       	ijmp

00000d72 <_exit>:
 d72:	f8 94       	cli

00000d74 <__stop_program>:
 d74:	ff cf       	rjmp	.-2      	; 0xd74 <__stop_program>
